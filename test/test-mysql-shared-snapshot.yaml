apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: test-shared-snapshot-mysql
  namespace: default
spec:
  serviceName: "mysql"
  replicas: 1
  selector:
    matchLabels:
      app: test-shared-snapshot-mysql
  template:
    metadata:
      labels:
        app: test-shared-snapshot-mysql
    spec:
      containers:
      - name: mysql
        image: business.tecorigin.io:5443/kubeflow/docker.io/library/mysql:8.0.29
        env:
        - name: MYSQL_ALLOW_EMPTY_PASSWORD
          value: "true"
        lifecycle:
          postStart:
            exec:
              command:
                - "/bin/sh"
                - "-c"
                - |
                  # Write to a file to prove the hook ran
                  echo "POST-START HOOK EXECUTED at $(date)" > /tmp/poststart.log 2>&1
                  echo "=== Post-Start Hook: Checking for previous session data ===" >> /tmp/poststart.log 2>&1
                  
                  # Also try to write to stdout/stderr
                  echo "POST-START HOOK RUNNING" >&1
                  echo "POST-START HOOK RUNNING" >&2
                  
                  # Determine own upperdir from mount info
                  MY_OWN_UPPERDIR_HOST_PATH=$(awk '/overlay/ && /upperdir=/ { 
                    # Find the field containing upperdir=
                    for (i=1; i<=NF; i++) { 
                      if ($i ~ /upperdir=/) { 
                        # Extract everything after upperdir= and before the next comma
                        match($i, /upperdir=([^,]+)/, arr)
                        if (arr[1] != "") {
                          print arr[1]
                          exit
                        }
                      } 
                    } 
                  }' /proc/self/mountinfo)
                  
                  echo "Raw mount info:" >> /tmp/poststart.log 2>&1
                  cat /proc/self/mountinfo | grep overlay >> /tmp/poststart.log 2>&1
                  echo "Extracted upperdir: '$MY_OWN_UPPERDIR_HOST_PATH'" >> /tmp/poststart.log 2>&1
                  
                  if [ -z "$MY_OWN_UPPERDIR_HOST_PATH" ]; then
                      echo "ERROR: Could not determine own shared upperdir. Proceeding with empty session." >> /tmp/poststart.log 2>&1
                      exit 0
                  fi
                  
                  echo "Current upperdir: $MY_OWN_UPPERDIR_HOST_PATH" >> /tmp/poststart.log 2>&1
                  MY_OWN_SNAPSHOT_ID=$(basename "$(dirname "$MY_OWN_UPPERDIR_HOST_PATH")")
                  echo "Current snapshot ID: $MY_OWN_SNAPSHOT_ID" >> /tmp/poststart.log 2>&1
                  
                  # Construct base path for this notebook identity
                  NOTEBOOK_SESSIONS_BASE_HOST_PATH=$(dirname "$(dirname "$MY_OWN_UPPERDIR_HOST_PATH")")
                  echo "Base sessions path: $NOTEBOOK_SESSIONS_BASE_HOST_PATH" >> /tmp/poststart.log 2>&1
                  
                  # Expected path based on the configuration: /nvme1/default/test-shared-snapshot-mysql/mysql/
                  EXPECTED_BASE_PATH="/nvme1/default/test-shared-snapshot-mysql-0/mysql"
                  if [ "$NOTEBOOK_SESSIONS_BASE_HOST_PATH" != "$EXPECTED_BASE_PATH" ]; then
                      echo "WARNING: Detected base path ($NOTEBOOK_SESSIONS_BASE_HOST_PATH) differs from expected ($EXPECTED_BASE_PATH)" >> /tmp/poststart.log 2>&1
                  fi
                  
                  # Look for previous session directories
                  PREVIOUS_SNAPSHOT_ID=""
                  PREVIOUS_SNAPSHOT_PATH=""
                  
                  if [ -d "$NOTEBOOK_SESSIONS_BASE_HOST_PATH" ]; then
                      echo "Scanning for previous session directories..." >> /tmp/poststart.log 2>&1
                      for D_HOST_PATH in "$NOTEBOOK_SESSIONS_BASE_HOST_PATH"/* ; do
                          if [ -d "${D_HOST_PATH}/fs" ]; then
                              SNAP_ID=$(basename "$D_HOST_PATH")
                              if [ "$SNAP_ID" != "$MY_OWN_SNAPSHOT_ID" ]; then
                                  # Check if directory has content (non-empty)
                                  if [ "$(ls -A "${D_HOST_PATH}/fs" 2>/dev/null)" ]; then
                                      echo "Found non-empty previous session: $SNAP_ID" >> /tmp/poststart.log 2>&1
                                      PREVIOUS_SNAPSHOT_ID=$SNAP_ID
                                      PREVIOUS_SNAPSHOT_PATH="${D_HOST_PATH}/fs"
                                      break
                                  else
                                      echo "Found empty previous session: $SNAP_ID (skipping)" >> /tmp/poststart.log 2>&1
                                  fi
                              fi
                          fi
                      done
                  fi
                  
                  # Restore from previous session if found
                  if [ -n "$PREVIOUS_SNAPSHOT_ID" ] && [ -n "$PREVIOUS_SNAPSHOT_PATH" ]; then
                      echo "=== Restoring from previous session: $PREVIOUS_SNAPSHOT_ID ===" >> /tmp/poststart.log 2>&1
                      echo "Source: $PREVIOUS_SNAPSHOT_PATH" >> /tmp/poststart.log 2>&1
                      echo "Target: $MY_OWN_UPPERDIR_HOST_PATH" >> /tmp/poststart.log 2>&1
                      
                      # Use rsync to copy data (preserving permissions, timestamps, etc.)
                      if command -v rsync >/dev/null 2>&1; then
                          echo "Using rsync for data migration..." >> /tmp/poststart.log 2>&1
                          rsync -avp --delete "${PREVIOUS_SNAPSHOT_PATH}/" "${MY_OWN_UPPERDIR_HOST_PATH}/" >> /tmp/poststart.log 2>&1
                          COPY_EXIT_CODE=$?
                      else
                          echo "rsync not available, using cp..." >> /tmp/poststart.log 2>&1
                          cp -rp "${PREVIOUS_SNAPSHOT_PATH}/." "${MY_OWN_UPPERDIR_HOST_PATH}/" >> /tmp/poststart.log 2>&1
                          COPY_EXIT_CODE=$?
                      fi
                      
                      if [ $COPY_EXIT_CODE -eq 0 ]; then
                          echo "=== Data migration successful ===" >> /tmp/poststart.log 2>&1
                          echo "Cleaning up old session directory: ${NOTEBOOK_SESSIONS_BASE_HOST_PATH}/${PREVIOUS_SNAPSHOT_ID}" >> /tmp/poststart.log 2>&1
                          rm -rf "${NOTEBOOK_SESSIONS_BASE_HOST_PATH}/${PREVIOUS_SNAPSHOT_ID}" >> /tmp/poststart.log 2>&1
                          if [ $? -eq 0 ]; then
                              echo "Old session directory cleaned up successfully" >> /tmp/poststart.log 2>&1
                          else
                              echo "WARNING: Failed to clean up old session directory" >> /tmp/poststart.log 2>&1
                          fi
                      else
                          echo "ERROR: Data migration failed (exit code: $COPY_EXIT_CODE). Old session data NOT cleaned up." >> /tmp/poststart.log 2>&1
                          echo "Manual intervention may be required." >> /tmp/poststart.log 2>&1
                          # Don't exit with error to allow container to start
                      fi
                  else
                      echo "No previous session data found. Starting with fresh session." >> /tmp/poststart.log 2>&1
                  fi
                  
                  echo "=== Post-Start Hook completed ===" >> /tmp/poststart.log 2>&1
        # Adding a simple command to ensure it writes some data and keeps running
        # MySQL will initialize its data directory on first start.
        # We'll also write a test file to a common location.
        command:
          - "/bin/sh"
          - "-c"
          - |
            echo "Test file in shared upperdir" > /tmp/my_test_file.txt
            datadir="$(mysqld --verbose --help 2>/dev/null | awk '$1 == "datadir" { print $2 }')"
            echo "MySQL data directory will be: ${datadir}"
            # Ensure the entrypoint script is executable if it isn't already
            chmod +x /usr/local/bin/docker-entrypoint.sh
            # Start MySQL in the background to allow it to initialize
            echo "Starting MySQL in background..."
            /usr/local/bin/docker-entrypoint.sh mysqld & mysqld_pid=$!
            echo "Waiting for MySQL to initialize (approx 30 seconds)..."
            sleep 30
            # Create a marker file after MySQL has had some time to initialize its directory
            if [ -d "${datadir}" ]; then
              echo "Creating marker file in ${datadir}/containerd_test_marker.txt"
              echo "This is a test marker file." > "${datadir}/containerd_test_marker.txt"
            else
              echo "MySQL data directory ${datadir} not found after startup."
            fi
            echo "MySQL started. Container will sleep for 10 minutes for inspection."
            echo "To stop, manually delete the pod or exec into it and kill PID $mysqld_pid or this script (PID $$)."
            # Keep the container running by waiting on the backgrounded MySQL process
            # If mysqld exits, this script will also exit.
            # Alternatively, a long sleep can be used if direct process waiting is problematic.
            # wait $mysqld_pid 
            # Using sleep as a simpler way to keep alive for inspection for a fixed time
            sleep 900 
            echo "Stopping MySQL..."
            kill $mysqld_pid
            wait $mysqld_pid 2>/dev/null || true
            echo "Exiting test script."
        # It's good practice to define resource requests/limits
        resources:
          limits:
            memory: "512Mi"
            cpu: "500m"
          requests:
            memory: "256Mi"
            cpu: "250m"
        volumeMounts:
        - name: shared-storage
          mountPath: /nvme1
      volumes:
      - name: shared-storage
        hostPath:
          path: /nvme1
          type: Directory 